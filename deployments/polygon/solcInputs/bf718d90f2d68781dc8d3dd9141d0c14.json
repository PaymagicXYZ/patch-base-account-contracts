{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./UserOperation.sol\";\n\n/**\n * the interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\n * a paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\n */\ninterface IPaymaster {\n    /**\n     * payment validation: check if paymaster agree to pay.\n     * Must verify sender is the entryPoint.\n     * Revert to reject this request.\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted)\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\n     * @param userOp the user operation\n     * @param userOpHash hash of the user's request data.\n     * @param maxCost the maximum cost of this transaction (based on maximum gas and gas price from userOp)\n     * @return context value to send to a postOp\n     *  zero length to signify postOp is not required.\n     * @return sigTimeRange signature and time-range of this operation, encoded the same as the return value of validateUserOperation\n     *      <byte> sigFailure - (1) to mark signature failure (needed only if paymaster uses signature-based validation,)\n     *      <8-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <8-byte> validAfter - first timestamp this operation is valid\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validatePaymasterUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external returns (bytes memory context, uint256 sigTimeRange);\n\n    /**\n     * post-operation handler.\n     * Must verify sender is the entryPoint\n     * @param mode enum with the following options:\n     *      opSucceeded - user operation succeeded.\n     *      opReverted  - user op reverted. still has to pay for gas.\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\n     * @param context - the context value returned by validatePaymasterUserOp\n     * @param actualGasCost - actual gas used so far (without this postOp call).\n     */\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost\n    ) external;\n\n    enum PostOpMode {\n        opSucceeded, // user op succeeded\n        opReverted, // user op reverted. still has to pay for gas.\n        postOpReverted //user op succeeded, but caused postOp to revert. Now its a 2nd call, after user's op was deliberately reverted.\n    }\n}\n"
    },
    "contracts/interfaces/UserOperation.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable no-inline-assembly */\n\n    /**\n     * User Operation struct\n     * @param sender the sender account of this request\n     * @param nonce unique value the sender uses to verify it is not a replay.\n     * @param initCode if set, the account contract will be created by this constructor\n     * @param callData the method call to execute on this account.\n     * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp\n     * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\n     * @param maxFeePerGas same as EIP-1559 gas parameter\n     * @param maxPriorityFeePerGas same as EIP-1559 gas parameter\n     * @param paymasterAndData if set, this field hold the paymaster address and \"paymaster-specific-data\". the paymaster will pay for the transaction instead of the sender\n     * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n     */\n    struct UserOperation {\n\n        address sender;\n        uint256 nonce;\n        bytes initCode;\n        bytes callData;\n        uint256 callGasLimit;\n        uint256 verificationGasLimit;\n        uint256 preVerificationGas;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n        bytes paymasterAndData;\n        bytes signature;\n    }\n\nlibrary UserOperationLib {\n\n    function getSender(UserOperation calldata userOp) internal pure returns (address) {\n        address data;\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\n        assembly {data := calldataload(userOp)}\n        return address(uint160(data));\n    }\n\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\n    // pay above what he signed for.\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint256) {\n    unchecked {\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        if (maxFeePerGas == maxPriorityFeePerGas) {\n            //legacy mode (for networks that don't support basefee opcode)\n            return maxFeePerGas;\n        }\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n    }\n    }\n\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\n        //lighter signature scheme. must match UserOp.ts#packUserOp\n        bytes calldata sig = userOp.signature;\n        // copy directly the userOp from calldata up to (but not including) the signature.\n        // this encoding depends on the ABI encoding of calldata, but is much lighter to copy\n        // than referencing each field separately.\n        assembly {\n            let ofs := userOp\n            let len := sub(sub(sig.offset, ofs), 32)\n            ret := mload(0x40)\n            mstore(0x40, add(ret, add(len, 32)))\n            mstore(ret, len)\n            calldatacopy(add(ret, 32), ofs, len)\n        }\n    }\n\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\n        return keccak256(pack(userOp));\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "contracts/core/EntryPoint.sol": {
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IPaymaster.sol\";\n\nimport \"../interfaces/IAggregatedAccount.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"../utils/Exec.sol\";\nimport \"./StakeManager.sol\";\nimport \"./SenderCreator.sol\";\n\ncontract EntryPoint is IEntryPoint, StakeManager {\n    using UserOperationLib for UserOperation;\n\n    SenderCreator private immutable senderCreator = new SenderCreator();\n\n    // internal value used during simulation: need to query aggregator.\n    address private constant SIMULATE_FIND_AGGREGATOR = address(1);\n\n    // marker for inner call revert on out of gas\n    bytes32 private constant INNER_OUT_OF_GAS = hex\"deaddead\";\n\n    uint256 private constant REVERT_REASON_MAX_LEN = 2048;\n\n    /**\n     * for simulation purposes, validateUserOp (and validatePaymasterUserOp) must return this value\n     * in case of signature failure, instead of revert.\n     */\n    uint256 public constant SIG_VALIDATION_FAILED = 1;\n\n    /**\n     * compensate the caller's beneficiary address with the collected fees of all UserOperations.\n     * @param beneficiary the address to receive the fees\n     * @param amount amount to transfer.\n     */\n    function _compensate(address payable beneficiary, uint256 amount) internal {\n        require(beneficiary != address(0), \"AA90 invalid beneficiary\");\n        (bool success, ) = beneficiary.call{value: amount}(\"\");\n        require(success, \"AA91 failed send to beneficiary\");\n    }\n\n    /**\n     * execute a user op\n     * @param opIndex into into the opInfo array\n     * @param userOp the userOp to execute\n     * @param opInfo the opInfo filled by validatePrepayment for this userOp.\n     * @return collected the total amount this userOp paid.\n     */\n    function _executeUserOp(\n        uint256 opIndex,\n        UserOperation calldata userOp,\n        UserOpInfo memory opInfo\n    ) private returns (uint256 collected) {\n        uint256 preGas = gasleft();\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\n\n        try this.innerHandleOp(userOp.callData, opInfo, context) returns (\n            uint256 _actualGasCost\n        ) {\n            collected = _actualGasCost;\n        } catch {\n            bytes32 innerRevertCode;\n            assembly {\n                returndatacopy(0, 0, 32)\n                innerRevertCode := mload(0)\n            }\n            // handleOps was called with gas limit too low. abort entire bundle.\n            if (innerRevertCode == INNER_OUT_OF_GAS) {\n                //report paymaster, since if it is deliberately caused by the bundler,\n                // it must be a revert caused by paymaster.\n                revert FailedOp(\n                    opIndex,\n                    opInfo.mUserOp.paymaster,\n                    \"AA95 out of gas\"\n                );\n            }\n\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            collected = _handlePostOp(\n                opIndex,\n                IPaymaster.PostOpMode.postOpReverted,\n                opInfo,\n                context,\n                actualGas\n            );\n        }\n    }\n\n    /**\n     * Execute a batch of UserOperation.\n     * no signature aggregator is used.\n     * if any account requires an aggregator (that is, it returned an \"actualAggregator\" when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(\n        UserOperation[] calldata ops,\n        address payable beneficiary\n    ) public {\n        uint256 opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n        unchecked {\n            for (uint256 i = 0; i < opslen; i++) {\n                UserOpInfo memory opInfo = opInfos[i];\n                (\n                    uint256 sigTimeRange,\n                    uint256 paymasterTimeRange,\n\n                ) = _validatePrepayment(i, ops[i], opInfo, address(0));\n                _validateSigTimeRange(\n                    i,\n                    opInfo,\n                    sigTimeRange,\n                    paymasterTimeRange\n                );\n            }\n\n            uint256 collected = 0;\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(i, ops[i], opInfos[i]);\n            }\n\n            _compensate(beneficiary, collected);\n        } //unchecked\n    }\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\n     * @param beneficiary the address to receive the fees\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) public {\n        uint256 opasLen = opsPerAggregator.length;\n        uint256 totalOps = 0;\n        for (uint256 i = 0; i < opasLen; i++) {\n            totalOps += opsPerAggregator[i].userOps.length;\n        }\n\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\n\n        uint256 opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            UserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n            uint256 opslen = ops.length;\n            for (uint256 i = 0; i < opslen; i++) {\n                UserOpInfo memory opInfo = opInfos[opIndex];\n                (\n                    uint256 sigTimeRange,\n                    uint256 paymasterTimeRange,\n\n                ) = _validatePrepayment(\n                        opIndex,\n                        ops[i],\n                        opInfo,\n                        address(aggregator)\n                    );\n                _validateSigTimeRange(\n                    i,\n                    opInfo,\n                    sigTimeRange,\n                    paymasterTimeRange\n                );\n                opIndex++;\n            }\n\n            if (address(aggregator) != address(0)) {\n                // solhint-disable-next-line no-empty-blocks\n                try aggregator.validateSignatures(ops, opa.signature) {} catch {\n                    revert SignatureValidationFailed(address(aggregator));\n                }\n            }\n        }\n\n        uint256 collected = 0;\n        opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            emit SignatureAggregatorChanged(address(opa.aggregator));\n            UserOperation[] calldata ops = opa.userOps;\n            uint256 opslen = ops.length;\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\n                opIndex++;\n            }\n        }\n        emit SignatureAggregatorChanged(address(0));\n\n        _compensate(beneficiary, collected);\n    }\n\n    function simulateHandleOp(\n        UserOperation calldata op,\n        address target,\n        bytes calldata targetCallData\n    ) external override {\n        UserOpInfo memory opInfo;\n\n        (\n            uint256 sigTimeRange,\n            uint256 paymasterTimeRange,\n\n        ) = _validatePrepayment(0, op, opInfo, SIMULATE_FIND_AGGREGATOR);\n        (, uint64 validAfter, uint64 validUntil) = _intersectTimeRange(\n            sigTimeRange,\n            paymasterTimeRange\n        );\n\n        numberMarker();\n        uint256 paid = _executeUserOp(0, op, opInfo);\n        numberMarker();\n        bool targetSuccess;\n        bytes memory targetResult;\n        if (target != address(0)) {\n            (targetSuccess, targetResult) = target.call(targetCallData);\n        }\n        revert ExecutionResult(\n            opInfo.preOpGas,\n            paid,\n            validAfter,\n            validUntil,\n            targetSuccess,\n            targetResult\n        );\n    }\n\n    //a memory copy of UserOp fields (except that dynamic byte arrays: callData, initCode and signature\n    struct MemoryUserOp {\n        address sender;\n        uint256 nonce;\n        uint256 callGasLimit;\n        uint256 verificationGasLimit;\n        uint256 preVerificationGas;\n        address paymaster;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n    }\n\n    struct UserOpInfo {\n        MemoryUserOp mUserOp;\n        bytes32 userOpHash;\n        uint256 prefund;\n        uint256 contextOffset;\n        uint256 preOpGas;\n    }\n\n    /**\n     * inner function to handle a UserOperation.\n     * Must be declared \"external\" to open a call context, but it can only be called by handleOps.\n     */\n    function innerHandleOp(\n        bytes memory callData,\n        UserOpInfo memory opInfo,\n        bytes calldata context\n    ) external returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        require(msg.sender == address(this), \"AA92 internal call only\");\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n        uint256 callGasLimit = mUserOp.callGasLimit;\n        unchecked {\n            // handleOps was called with gas limit too low. abort entire bundle.\n            if (\n                gasleft() < callGasLimit + mUserOp.verificationGasLimit + 5000\n            ) {\n                assembly {\n                    mstore(0, INNER_OUT_OF_GAS)\n                    revert(0, 32)\n                }\n            }\n        }\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (callData.length > 0) {\n            bool success = Exec.call(mUserOp.sender, 0, callData, callGasLimit);\n            if (!success) {\n                bytes memory result = Exec.getReturnData(REVERT_REASON_MAX_LEN);\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(\n                        opInfo.userOpHash,\n                        mUserOp.sender,\n                        mUserOp.nonce,\n                        result\n                    );\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n        unchecked {\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\n            return _handlePostOp(0, mode, opInfo, context, actualGas);\n        }\n    }\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     */\n    function getUserOpHash(UserOperation calldata userOp)\n        public\n        view\n        returns (bytes32)\n    {\n        return\n            keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n     * copy general fields from userOp into the memory opInfo structure.\n     */\n    function _copyUserOpToMemory(\n        UserOperation calldata userOp,\n        MemoryUserOp memory mUserOp\n    ) internal pure {\n        mUserOp.sender = userOp.sender;\n        mUserOp.nonce = userOp.nonce;\n        mUserOp.callGasLimit = userOp.callGasLimit;\n        mUserOp.verificationGasLimit = userOp.verificationGasLimit;\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\n        mUserOp.maxFeePerGas = userOp.maxFeePerGas;\n        mUserOp.maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        if (paymasterAndData.length > 0) {\n            require(\n                paymasterAndData.length >= 20,\n                \"AA93 invalid paymasterAndData\"\n            );\n            mUserOp.paymaster = address(bytes20(paymasterAndData[:20]));\n        } else {\n            mUserOp.paymaster = address(0);\n        }\n    }\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\n     * @param userOp the user operation to validate.\n     */\n    function simulateValidation(UserOperation calldata userOp) external {\n        UserOpInfo memory outOpInfo;\n\n        (\n            uint256 sigTimeRange,\n            uint256 paymasterTimeRange,\n            address aggregator\n        ) = _validatePrepayment(0, userOp, outOpInfo, SIMULATE_FIND_AGGREGATOR);\n        StakeInfo memory paymasterInfo = getStakeInfo(\n            outOpInfo.mUserOp.paymaster\n        );\n        StakeInfo memory senderInfo = getStakeInfo(outOpInfo.mUserOp.sender);\n        StakeInfo memory factoryInfo;\n        {\n            bytes calldata initCode = userOp.initCode;\n            address factory = initCode.length >= 20\n                ? address(bytes20(initCode[0:20]))\n                : address(0);\n            factoryInfo = getStakeInfo(factory);\n        }\n\n        (\n            bool sigFailed,\n            uint64 validAfter,\n            uint64 validUntil\n        ) = _intersectTimeRange(sigTimeRange, paymasterTimeRange);\n        ReturnInfo memory returnInfo = ReturnInfo(\n            outOpInfo.preOpGas,\n            outOpInfo.prefund,\n            sigFailed,\n            validAfter,\n            validUntil,\n            getMemoryBytesFromOffset(outOpInfo.contextOffset)\n        );\n\n        if (aggregator != address(0)) {\n            AggregatorStakeInfo memory aggregatorInfo = AggregatorStakeInfo(\n                aggregator,\n                getStakeInfo(aggregator)\n            );\n            revert ValidationResultWithAggregation(\n                returnInfo,\n                senderInfo,\n                factoryInfo,\n                paymasterInfo,\n                aggregatorInfo\n            );\n        }\n        revert ValidationResult(\n            returnInfo,\n            senderInfo,\n            factoryInfo,\n            paymasterInfo\n        );\n    }\n\n    function _getRequiredPrefund(MemoryUserOp memory mUserOp)\n        internal\n        pure\n        returns (uint256 requiredPrefund)\n    {\n        unchecked {\n            //when using a Paymaster, the verificationGasLimit is used also to as a limit for the postOp call.\n            // our security model might call postOp eventually twice\n            uint256 mul = mUserOp.paymaster != address(0) ? 3 : 1;\n            uint256 requiredGas = mUserOp.callGasLimit +\n                mUserOp.verificationGasLimit *\n                mul +\n                mUserOp.preVerificationGas;\n\n            requiredPrefund = requiredGas * mUserOp.maxFeePerGas;\n        }\n    }\n\n    // create the sender's contract if needed.\n    function _createSenderIfNeeded(\n        uint256 opIndex,\n        UserOpInfo memory opInfo,\n        bytes calldata initCode\n    ) internal {\n        if (initCode.length != 0) {\n            address sender = opInfo.mUserOp.sender;\n            if (sender.code.length != 0)\n                revert FailedOp(\n                    opIndex,\n                    address(0),\n                    \"AA10 sender already constructed\"\n                );\n            address sender1 = senderCreator.createSender{\n                gas: opInfo.mUserOp.verificationGasLimit\n            }(initCode);\n            if (sender1 == address(0))\n                revert FailedOp(\n                    opIndex,\n                    address(0),\n                    \"AA13 initCode failed or OOG\"\n                );\n            if (sender1 != sender)\n                revert FailedOp(\n                    opIndex,\n                    address(0),\n                    \"AA14 initCode must return sender\"\n                );\n            if (sender1.code.length == 0)\n                revert FailedOp(\n                    opIndex,\n                    address(0),\n                    \"AA15 initCode must create sender\"\n                );\n            address factory = address(bytes20(initCode[0:20]));\n            emit AccountDeployed(\n                opInfo.userOpHash,\n                sender,\n                factory,\n                opInfo.mUserOp.paymaster\n            );\n        }\n    }\n\n    /**\n     * Get counterfactual sender address.\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * this method always revert, and returns the address in SenderAddressResult error\n     * @param initCode the constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes calldata initCode) public {\n        revert SenderAddressResult(senderCreator.createSender(initCode));\n    }\n\n    /**\n     * Get aggregator from sender account as revert reason.\n     * Called only during simulation.\n     * This function always reverts to prevent warm/cold storage differentiation in simulation vs execution.\n     */\n    function _simulateFindAggregator(address sender, address paymaster)\n        external\n        view\n    {\n        require(msg.sender == address(this), \"AA92 internal call only\");\n        address aggregator;\n        if (sender.code.length == 0) {\n            // it would revert anyway. but give a meaningful message\n            revert(\"AA20 account not deployed\");\n        }\n        if (paymaster != address(0) && paymaster.code.length == 0) {\n            // it would revert anyway. but give a meaningful message\n            revert(\"AA30 paymaster not deployed\");\n        }\n        // during simulation, we don't use given aggregator,\n        // but query the account for its aggregator\n        try IAggregatedAccount(sender).getAggregator() returns (\n            address userOpAggregator\n        ) {\n            aggregator = userOpAggregator;\n        } catch {\n            aggregator = address(0);\n        }\n        assembly {\n            mstore(0, aggregator)\n            revert(0, 32)\n        }\n    }\n\n    /**\n     * call account.validateUserOp.\n     * revert (with FailedOp) in case validateUserOp reverts, or account didn't send required prefund.\n     * decrement account's deposit if needed\n     */\n    function _validateAccountPrepayment(\n        uint256 opIndex,\n        UserOperation calldata op,\n        UserOpInfo memory opInfo,\n        address aggregator,\n        uint256 requiredPrefund\n    )\n        internal\n        returns (\n            uint256 gasUsedByValidateAccountPrepayment,\n            address actualAggregator,\n            uint256 sigTimeRange\n        )\n    {\n        unchecked {\n            uint256 preGas = gasleft();\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            address sender = mUserOp.sender;\n            _createSenderIfNeeded(opIndex, opInfo, op.initCode);\n            address paymaster = mUserOp.paymaster;\n            if (aggregator == SIMULATE_FIND_AGGREGATOR) {\n                numberMarker();\n\n                // solhint-disable-next-line no-empty-blocks\n                try\n                    this._simulateFindAggregator(sender, paymaster)\n                {} catch Error(string memory revertReason) {\n                    revert FailedOp(opIndex, paymaster, revertReason);\n                } catch (bytes memory revertReason) {\n                    if (revertReason.length != 32) {\n                        // Should not get here, since every revert other than aggregator should be handled\n                        // in the previous catch block.\n                        revert FailedOp(0, paymaster, string(revertReason));\n                    }\n                    aggregator = actualAggregator = abi.decode(\n                        revertReason,\n                        (address)\n                    );\n                }\n            }\n            uint256 missingAccountFunds = 0;\n            if (paymaster == address(0)) {\n                uint256 bal = balanceOf(sender);\n                missingAccountFunds = bal > requiredPrefund\n                    ? 0\n                    : requiredPrefund - bal;\n            }\n            try\n                IAccount(sender).validateUserOp{\n                    gas: mUserOp.verificationGasLimit\n                }(op, opInfo.userOpHash, aggregator, missingAccountFunds)\n            returns (uint256 _sigTimeRange) {\n                sigTimeRange = _sigTimeRange;\n            } catch Error(string memory revertReason) {\n                revert FailedOp(opIndex, address(0), revertReason);\n            } catch {\n                revert FailedOp(opIndex, address(0), \"AA23 reverted (or OOG)\");\n            }\n            if (paymaster == address(0)) {\n                DepositInfo storage senderInfo = deposits[sender];\n                uint256 deposit = senderInfo.deposit;\n                if (requiredPrefund > deposit) {\n                    revert FailedOp(\n                        opIndex,\n                        address(0),\n                        \"AA21 didn't pay prefund\"\n                    );\n                }\n                senderInfo.deposit = uint112(deposit - requiredPrefund);\n            }\n            gasUsedByValidateAccountPrepayment = preGas - gasleft();\n        }\n    }\n\n    /**\n     * in case the request has a paymaster:\n     * validate paymaster is staked and has enough deposit.\n     * call paymaster.validatePaymasterUserOp.\n     * revert with proper FailedOp in case paymaster reverts.\n     * decrement paymaster's deposit\n     */\n    function _validatePaymasterPrepayment(\n        uint256 opIndex,\n        UserOperation calldata op,\n        UserOpInfo memory opInfo,\n        uint256 requiredPreFund,\n        uint256 gasUsedByValidateAccountPrepayment\n    ) internal returns (bytes memory context, uint256 sigTimeRange) {\n        unchecked {\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            uint256 verificationGasLimit = mUserOp.verificationGasLimit;\n            require(\n                verificationGasLimit > gasUsedByValidateAccountPrepayment,\n                \"AA41 too little verificationGas\"\n            );\n            uint256 gas = verificationGasLimit -\n                gasUsedByValidateAccountPrepayment;\n\n            address paymaster = mUserOp.paymaster;\n            DepositInfo storage paymasterInfo = deposits[paymaster];\n            uint256 deposit = paymasterInfo.deposit;\n            if (deposit < requiredPreFund) {\n                revert FailedOp(\n                    opIndex,\n                    paymaster,\n                    \"AA31 paymaster deposit too low\"\n                );\n            }\n            paymasterInfo.deposit = uint112(deposit - requiredPreFund);\n            try\n                IPaymaster(paymaster).validatePaymasterUserOp{gas: gas}(\n                    op,\n                    opInfo.userOpHash,\n                    requiredPreFund\n                )\n            returns (bytes memory _context, uint256 _sigTimeRange) {\n                context = _context;\n                sigTimeRange = _sigTimeRange;\n            } catch Error(string memory revertReason) {\n                revert FailedOp(opIndex, paymaster, revertReason);\n            } catch {\n                revert FailedOp(opIndex, paymaster, \"AA33 reverted (or OOG)\");\n            }\n        }\n    }\n\n    /**\n     * revert if either account sigTimeRange or paymaster sigTimeRange is expired\n     */\n    function _validateSigTimeRange(\n        uint256 opIndex,\n        UserOpInfo memory opInfo,\n        uint256 sigTimeRange,\n        uint256 paymasterTimeRange\n    ) internal view {\n        (bool sigFailed, bool outOfTimeRange) = _getSigTimeRange(sigTimeRange);\n        if (sigFailed) {\n            revert FailedOp(opIndex, address(0), \"AA24 signature error\");\n        }\n        if (outOfTimeRange) {\n            revert FailedOp(opIndex, address(0), \"AA22 expired or not due\");\n        }\n        (sigFailed, outOfTimeRange) = _getSigTimeRange(paymasterTimeRange);\n        if (sigFailed) {\n            revert FailedOp(\n                opIndex,\n                opInfo.mUserOp.paymaster,\n                \"AA34 signature error\"\n            );\n        }\n        if (outOfTimeRange) {\n            revert FailedOp(\n                opIndex,\n                opInfo.mUserOp.paymaster,\n                \"AA32 paymaster expired or not due\"\n            );\n        }\n    }\n\n    function _getSigTimeRange(uint256 sigTimeRange)\n        internal\n        view\n        returns (bool sigFailed, bool outOfTimeRange)\n    {\n        if (sigTimeRange == 0) {\n            return (false, false);\n        }\n        uint256 validAfter;\n        uint256 validUntil;\n        (sigFailed, validAfter, validUntil) = _parseSigTimeRange(sigTimeRange);\n        // solhint-disable-next-line not-rely-on-time\n        outOfTimeRange =\n            block.timestamp > validUntil ||\n            block.timestamp < validAfter;\n    }\n\n    //extract sigFailed, validAfter, validUntil.\n    // also convert zero validUntil to type(uint64).max\n    function _parseSigTimeRange(uint256 sigTimeRange)\n        internal\n        pure\n        returns (\n            bool sigFailed,\n            uint64 validAfter,\n            uint64 validUntil\n        )\n    {\n        sigFailed = uint8(sigTimeRange) != 0;\n        // subtract one, to explicitly treat zero as max-value\n        validUntil = uint64(int64(int256(sigTimeRange >> 8) - 1));\n        validAfter = uint64(sigTimeRange >> (8 + 64));\n    }\n\n    // intersect account and paymaster ranges.\n    function _intersectTimeRange(\n        uint256 sigTimeRange,\n        uint256 paymasterTimeRange\n    )\n        internal\n        pure\n        returns (\n            bool sigFailed,\n            uint64 validAfter,\n            uint64 validUntil\n        )\n    {\n        (sigFailed, validAfter, validUntil) = _parseSigTimeRange(sigTimeRange);\n        (\n            bool pmSigFailed,\n            uint64 pmValidAfter,\n            uint64 pmValidUntil\n        ) = _parseSigTimeRange(paymasterTimeRange);\n        sigFailed = sigFailed || pmSigFailed;\n\n        if (validAfter < pmValidAfter) validAfter = pmValidAfter;\n        if (validUntil > pmValidUntil) validUntil = pmValidUntil;\n    }\n\n    /**\n     * validate account and paymaster (if defined).\n     * also make sure total validation doesn't exceed verificationGasLimit\n     * this method is called off-chain (simulateValidation()) and on-chain (from handleOps)\n     * @param opIndex the index of this userOp into the \"opInfos\" array\n     * @param userOp the userOp to validate\n     */\n    function _validatePrepayment(\n        uint256 opIndex,\n        UserOperation calldata userOp,\n        UserOpInfo memory outOpInfo,\n        address aggregator\n    )\n        private\n        returns (\n            uint256 sigTimeRange,\n            uint256 paymasterTimeRange,\n            address actualAggregator\n        )\n    {\n        uint256 preGas = gasleft();\n        MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\n        _copyUserOpToMemory(userOp, mUserOp);\n        outOpInfo.userOpHash = getUserOpHash(userOp);\n\n        // validate all numeric values in userOp are well below 128 bit, so they can safely be added\n        // and multiplied without causing overflow\n        uint256 maxGasValues = mUserOp.preVerificationGas |\n            mUserOp.verificationGasLimit |\n            mUserOp.callGasLimit |\n            userOp.maxFeePerGas |\n            userOp.maxPriorityFeePerGas;\n        require(maxGasValues <= type(uint120).max, \"AA94 gas values overflow\");\n\n        uint256 gasUsedByValidateAccountPrepayment;\n        uint256 requiredPreFund = _getRequiredPrefund(mUserOp);\n        (\n            gasUsedByValidateAccountPrepayment,\n            actualAggregator,\n            sigTimeRange\n        ) = _validateAccountPrepayment(\n            opIndex,\n            userOp,\n            outOpInfo,\n            aggregator,\n            requiredPreFund\n        );\n        //a \"marker\" where account opcode validation is done and paymaster opcode validation is about to start\n        // (used only by off-chain simulateValidation)\n        numberMarker();\n\n        bytes memory context;\n        if (mUserOp.paymaster != address(0)) {\n            (context, paymasterTimeRange) = _validatePaymasterPrepayment(\n                opIndex,\n                userOp,\n                outOpInfo,\n                requiredPreFund,\n                gasUsedByValidateAccountPrepayment\n            );\n        }\n        unchecked {\n            uint256 gasUsed = preGas - gasleft();\n\n            if (userOp.verificationGasLimit < gasUsed) {\n                revert FailedOp(\n                    opIndex,\n                    mUserOp.paymaster,\n                    \"AA40 over verificationGasLimit\"\n                );\n            }\n            outOpInfo.prefund = requiredPreFund;\n            outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\n            outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n        }\n    }\n\n    /**\n     * process post-operation.\n     * called just after the callData is executed.\n     * if a paymaster is defined and its validation returned a non-empty context, its postOp is called.\n     * the excess amount is refunded to the account (or paymaster - if it is was used in the request)\n     * @param opIndex index in the batch\n     * @param mode - whether is called from innerHandleOp, or outside (postOpReverted)\n     * @param opInfo userOp fields and info collected during validation\n     * @param context the context returned in validatePaymasterUserOp\n     * @param actualGas the gas used so far by this user operation\n     */\n    function _handlePostOp(\n        uint256 opIndex,\n        IPaymaster.PostOpMode mode,\n        UserOpInfo memory opInfo,\n        bytes memory context,\n        uint256 actualGas\n    ) private returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        unchecked {\n            address refundAddress;\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            uint256 gasPrice = getUserOpGasPrice(mUserOp);\n\n            address paymaster = mUserOp.paymaster;\n            if (paymaster == address(0)) {\n                refundAddress = mUserOp.sender;\n            } else {\n                refundAddress = paymaster;\n                if (context.length > 0) {\n                    actualGasCost = actualGas * gasPrice;\n                    if (mode != IPaymaster.PostOpMode.postOpReverted) {\n                        IPaymaster(paymaster).postOp{\n                            gas: mUserOp.verificationGasLimit\n                        }(mode, context, actualGasCost);\n                    } else {\n                        // solhint-disable-next-line no-empty-blocks\n                        try\n                            IPaymaster(paymaster).postOp{\n                                gas: mUserOp.verificationGasLimit\n                            }(mode, context, actualGasCost)\n                        {} catch Error(string memory reason) {\n                            revert FailedOp(opIndex, paymaster, reason);\n                        } catch {\n                            revert FailedOp(\n                                opIndex,\n                                paymaster,\n                                \"A50 postOp revert\"\n                            );\n                        }\n                    }\n                }\n            }\n            actualGas += preGas - gasleft();\n            actualGasCost = actualGas * gasPrice;\n            if (opInfo.prefund < actualGasCost) {\n                revert FailedOp(\n                    opIndex,\n                    paymaster,\n                    \"A51 prefund below actualGasCost\"\n                );\n            }\n            uint256 refund = opInfo.prefund - actualGasCost;\n            internalIncrementDeposit(refundAddress, refund);\n            bool success = mode == IPaymaster.PostOpMode.opSucceeded;\n            emit UserOperationEvent(\n                opInfo.userOpHash,\n                mUserOp.sender,\n                mUserOp.paymaster,\n                mUserOp.nonce,\n                success,\n                actualGasCost,\n                actualGas\n            );\n        } // unchecked\n    }\n\n    /**\n     * the gas price this UserOp agrees to pay.\n     * relayer/block builder might submit the TX with higher priorityFee, but the user should not\n     */\n    function getUserOpGasPrice(MemoryUserOp memory mUserOp)\n        internal\n        view\n        returns (uint256)\n    {\n        unchecked {\n            uint256 maxFeePerGas = mUserOp.maxFeePerGas;\n            uint256 maxPriorityFeePerGas = mUserOp.maxPriorityFeePerGas;\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function getOffsetOfMemoryBytes(bytes memory data)\n        internal\n        pure\n        returns (uint256 offset)\n    {\n        assembly {\n            offset := data\n        }\n    }\n\n    function getMemoryBytesFromOffset(uint256 offset)\n        internal\n        pure\n        returns (bytes memory data)\n    {\n        assembly {\n            data := offset\n        }\n    }\n\n    //place the NUMBER opcode in the code.\n    // this is used as a marker during simulation, as this OP is completely banned from the simulated code of the\n    // account and paymaster.\n    function numberMarker() internal view {\n        assembly {\n            mstore(0, number())\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./UserOperation.sol\";\n\ninterface IAccount {\n\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp the operation that is about to be executed.\n     * @param userOpHash hash of the user's request data. can be used as the basis for signature.\n     * @param aggregator the aggregator used to validate the signature. NULL for non-aggregated signature accounts.\n     * @param missingAccountFunds missing funds on the account's deposit in the entrypoint.\n     *      This is the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\n     *      The excess is left as a deposit in the entrypoint, for future calls.\n     *      can be withdrawn anytime using \"entryPoint.withdrawTo()\"\n     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero.\n     * @return sigTimeRange signature and time-range of this operation\n     *      <byte> sigFailure - (1) to mark signature failure, 0 for valid signature.\n     *      <8-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <8-byte> validAfter - first timestamp this operation is valid\n     *      The an account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address aggregator, uint256 missingAccountFunds)\n    external returns (uint256 sigTimeRange);\n}\n"
    },
    "contracts/interfaces/IAggregatedAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./UserOperation.sol\";\nimport \"./IAccount.sol\";\nimport \"./IAggregator.sol\";\n\n/**\n * Aggregated account, that support IAggregator.\n * - the validateUserOp will be called only after the aggregator validated this account (with all other accounts of this aggregator).\n * - the validateUserOp MUST valiate the aggregator parameter, and MAY ignore the userOp.signature field.\n */\ninterface IAggregatedAccount is IAccount {\n\n    /**\n     * return the address of the signature aggregator the account supports.\n     */\n    function getAggregator() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IEntryPoint.sol": {
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./UserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\n\ninterface IEntryPoint is IStakeManager {\n    /***\n     * An event emitted after each successful request\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\n     * @param sender - the account that generates this request.\n     * @param paymaster - if non-null, the paymaster that pays for this request.\n     * @param nonce - the nonce value from the request\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution)\n     * @param success - true if the sender transaction succeeded, false if reverted.\n     */\n    event UserOperationEvent(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address indexed paymaster,\n        uint256 nonce,\n        bool success,\n        uint256 actualGasCost,\n        uint256 actualGasUsed\n    );\n\n    /**\n     * account \"sender\" was deployed.\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender the account that is deployed\n     * @param factory the factory used to deploy this account (in the initCode)\n     * @param paymaster the paymaster used by this UserOp\n     */\n    event AccountDeployed(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address factory,\n        address paymaster\n    );\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length\n     * @param userOpHash the request unique identifier.\n     * @param sender the sender of this request\n     * @param nonce the nonce used in the request\n     * @param revertReason - the return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * signature aggregator used by the following UserOperationEvents within this bundle.\n     */\n    event SignatureAggregatorChanged(address aggregator);\n\n    /**\n     * a custom revert error of handleOps, to identify the offending op.\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\n     *  @param paymaster - if paymaster.validatePaymasterUserOp fails, this will be the paymaster's address. if validateUserOp failed,\n     *       this value will be zero (since it failed before accessing the paymaster)\n     *  @param reason - revert reason\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of account/paymaster reverts.\n     */\n    error FailedOp(uint256 opIndex, address paymaster, string reason);\n\n    /**\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    //UserOps handled, per aggregator\n    struct UserOpsPerAggregator {\n        UserOperation[] userOps;\n        // aggregator address\n        IAggregator aggregator;\n        // aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperation.\n     * no signature aggregator is used.\n     * if any account requires an aggregator (that is, it returned an \"actualAggregator\" when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(\n        UserOperation[] calldata ops,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\n     * @param beneficiary the address to receive the fees\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     */\n    function getUserOpHash(UserOperation calldata userOp)\n        external\n        view\n        returns (bytes32);\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\n     * @param userOp the user operation to validate.\n     */\n    function simulateValidation(UserOperation calldata userOp) external;\n\n    /**\n     * Successful result from simulateValidation.\n     * @param returnInfo gas and time-range returned values\n     * @param senderInfo stake information about the sender\n     * @param factoryInfo stake information about the factor (if any)\n     * @param paymasterInfo stake information about the paymaster (if any)\n     */\n    error ValidationResult(\n        ReturnInfo returnInfo,\n        StakeInfo senderInfo,\n        StakeInfo factoryInfo,\n        StakeInfo paymasterInfo\n    );\n\n    /**\n     * Successful result from simulateValidation, if the account returns a signature aggregator\n     * @param returnInfo gas and time-range returned values\n     * @param senderInfo stake information about the sender\n     * @param factoryInfo stake information about the factor (if any)\n     * @param paymasterInfo stake information about the paymaster (if any)\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\n     */\n    error ValidationResultWithAggregation(\n        ReturnInfo returnInfo,\n        StakeInfo senderInfo,\n        StakeInfo factoryInfo,\n        StakeInfo paymasterInfo,\n        AggregatorStakeInfo aggregatorInfo\n    );\n\n    /**\n     * gas and return values during simulation\n     * @param preOpGas the gas used for validation (including preValidationGas)\n     * @param prefund the required prefund for this operation\n     * @param sigFailed validateUserOp's (or paymaster's) signature check failed\n     * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\n     * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        bool sigFailed;\n        uint64 validAfter;\n        uint64 validUntil;\n        bytes paymasterContext;\n    }\n\n    /**\n     * returned aggregated signature info.\n     * the aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address actualAggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * this method always revert, and returns the address in SenderAddressResult error\n     * @param initCode the constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    /**\n     * return value of getSenderAddress\n     */\n    error SenderAddressResult(address sender);\n\n    /**\n     * simulate full execution of a UserOperation (including both validation and target execution)\n     * this method will always revert with \"ExecutionResult\".\n     * it performs full validation of the UserOperation, but ignores signature error.\n     * an optional target address is called after the userop succeeds, and its value is returned\n     * (before the entire call is reverted)\n     * Note that in order to collect the the success/failure of the target call, it must be executed\n     * with trace enabled to track the emitted events.\n     * @param op the UserOperation to simulate\n     * @param target if nonzero, a target address to call after userop simulation. If called, the targetSuccess and targetResult\n     *        are set to the return from that call.\n     * @param targetCallData callData to pass to target address\n     */\n    function simulateHandleOp(\n        UserOperation calldata op,\n        address target,\n        bytes calldata targetCallData\n    ) external;\n\n    error ExecutionResult(\n        uint256 preOpGas,\n        uint256 paid,\n        uint64 validAfter,\n        uint64 validBefore,\n        bool targetSuccess,\n        bytes targetResult\n    );\n}\n"
    },
    "contracts/utils/Exec.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.5 <0.9.0;\n\n// solhint-disable no-inline-assembly\n\nlibrary Exec {\n    function call(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly {\n            success := call(\n                txGas,\n                to,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n        }\n    }\n\n    function staticcall(\n        address to,\n        bytes memory data,\n        uint256 txGas\n    ) internal view returns (bool success) {\n        assembly {\n            success := staticcall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    function delegateCall(\n        address to,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly {\n            success := delegatecall(\n                txGas,\n                to,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n        }\n    }\n\n    // get returned data from last call or calldelegate\n    function getReturnData(uint256 maxLen)\n        internal\n        pure\n        returns (bytes memory returnData)\n    {\n        assembly {\n            let len := returndatasize()\n            if gt(len, maxLen) {\n                len := maxLen\n            }\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, add(len, 0x20)))\n            mstore(ptr, len)\n            returndatacopy(add(ptr, 0x20), 0, len)\n            returnData := ptr\n        }\n    }\n\n    // revert with explicit byte array (probably reverted info from call)\n    function revertWithData(bytes memory returnData) internal pure {\n        assembly {\n            revert(add(returnData, 32), mload(returnData))\n        }\n    }\n\n    function callAndRevert(\n        address to,\n        bytes memory data,\n        uint256 maxLen\n    ) internal {\n        bool success = call(to, 0, data, gasleft());\n        if (!success) {\n            revertWithData(getReturnData(maxLen));\n        }\n    }\n}\n"
    },
    "contracts/core/StakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\nimport \"../interfaces/IStakeManager.sol\";\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable not-rely-on-time */\n/**\n * manage deposits and stakes.\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\n * stake is value locked for at least \"unstakeDelay\" by a paymaster.\n */\nabstract contract StakeManager is IStakeManager {\n\n    /// maps paymaster to their deposits and stakes\n    mapping(address => DepositInfo) public deposits;\n\n    function getDepositInfo(address account) public view returns (DepositInfo memory info) {\n        return deposits[account];\n    }\n\n    // internal method to return just the stake info\n    function getStakeInfo(address addr) internal view returns (StakeInfo memory info) {\n        DepositInfo storage depositInfo = deposits[addr];\n        info.stake = depositInfo.stake;\n        info.unstakeDelaySec = depositInfo.unstakeDelaySec;\n    }\n\n    /// return the deposit (for gas payment) of the account\n    function balanceOf(address account) public view returns (uint256) {\n        return deposits[account].deposit;\n    }\n\n    receive() external payable {\n        depositTo(msg.sender);\n    }\n\n    function internalIncrementDeposit(address account, uint256 amount) internal {\n        DepositInfo storage info = deposits[account];\n        uint256 newAmount = info.deposit + amount;\n        require(newAmount <= type(uint112).max, \"deposit overflow\");\n        info.deposit = uint112(newAmount);\n    }\n\n    /**\n     * add to the deposit of the given account\n     */\n    function depositTo(address account) public payable {\n        internalIncrementDeposit(account, msg.value);\n        DepositInfo storage info = deposits[account];\n        emit Deposited(account, info.deposit);\n    }\n\n    /**\n     * add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) public payable {\n        DepositInfo storage info = deposits[msg.sender];\n        require(_unstakeDelaySec > 0, \"must specify unstake delay\");\n        require(_unstakeDelaySec >= info.unstakeDelaySec, \"cannot decrease unstake time\");\n        uint256 stake = info.stake + msg.value;\n        require(stake > 0, \"no stake specified\");\n        require(stake < type(uint112).max, \"stake overflow\");\n        deposits[msg.sender] = DepositInfo(\n            info.deposit,\n            true,\n            uint112(stake),\n            _unstakeDelaySec,\n            0\n        );\n        emit StakeLocked(msg.sender, stake, _unstakeDelaySec);\n    }\n\n    /**\n     * attempt to unlock the stake.\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(info.unstakeDelaySec != 0, \"not staked\");\n        require(info.staked, \"already unstaking\");\n        uint64 withdrawTime = uint64(block.timestamp) + info.unstakeDelaySec;\n        info.withdrawTime = withdrawTime;\n        info.staked = false;\n        emit StakeUnlocked(msg.sender, withdrawTime);\n    }\n\n\n    /**\n     * withdraw from the (unlocked) stake.\n     * must first call unlockStake and wait for the unstakeDelay to pass\n     * @param withdrawAddress the address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external {\n        DepositInfo storage info = deposits[msg.sender];\n        uint256 stake = info.stake;\n        require(stake > 0, \"No stake to withdraw\");\n        require(info.withdrawTime > 0, \"must call unlockStake() first\");\n        require(info.withdrawTime <= block.timestamp, \"Stake withdrawal is not due\");\n        info.unstakeDelaySec = 0;\n        info.withdrawTime = 0;\n        info.stake = 0;\n        emit StakeWithdrawn(msg.sender, withdrawAddress, stake);\n        (bool success,) = withdrawAddress.call{value : stake}(\"\");\n        require(success, \"failed to withdraw stake\");\n    }\n\n    /**\n     * withdraw from the deposit.\n     * @param withdrawAddress the address to send withdrawn value.\n     * @param withdrawAmount the amount to withdraw.\n     */\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\n        info.deposit = uint112(info.deposit - withdrawAmount);\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n        (bool success,) = withdrawAddress.call{value : withdrawAmount}(\"\");\n        require(success, \"failed to withdraw\");\n    }\n}\n"
    },
    "contracts/core/SenderCreator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/**\n * helper contract for EntryPoint, to call userOp.initCode from a \"neutral\" address,\n * which is explicitly not the entryPoint itself.\n */\ncontract SenderCreator {\n\n    /**\n     * call the \"initCode\" factory to create and return the sender account address\n     * @param initCode the initCode value from a UserOp. contains 20 bytes of factory address, followed by calldata\n     * @return sender the returned address of the created account, or zero address on failure.\n     */\n    function createSender(bytes calldata initCode) external returns (address sender) {\n        address initAddress = address(bytes20(initCode[0 : 20]));\n        bytes memory initCallData = initCode[20 :];\n        bool success;\n        /* solhint-disable no-inline-assembly */\n        assembly {\n            success := call(gas(), initAddress, 0, add(initCallData, 0x20), mload(initCallData), 0, 32)\n            sender := mload(0)\n        }\n        if (!success) {\n            sender = address(0);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./UserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n\n    /**\n     * validate aggregated signature.\n     * revert if the aggregated signature does not match the given list of operations.\n     */\n    function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature) external view;\n\n    /**\n     * validate signature of a single userOp\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\n     * First it validates the signature over the userOp. then it return data to be used when creating the handleOps:\n     * @param userOp the userOperation received from the user.\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\n     *    (usually empty, unless account and aggregator support some kind of \"multisig\"\n     */\n    function validateUserOpSignature(UserOperation calldata userOp)\n    external view returns (bytes memory sigForUserOp);\n\n    /**\n     * aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation\n     * @param userOps array of UserOperations to collect the signatures from.\n     * @return aggregatesSignature the aggregated signature\n     */\n    function aggregateSignatures(UserOperation[] calldata userOps) external view returns (bytes memory aggregatesSignature);\n}\n"
    },
    "contracts/interfaces/IStakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\n/**\n * manage deposits and stakes.\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\n * stake is value locked for at least \"unstakeDelay\" by a paymaster.\n */\ninterface IStakeManager {\n\n    event Deposited(\n        address indexed account,\n        uint256 totalDeposit\n    );\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /// Emitted once a stake is scheduled for withdrawal\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 withdrawTime\n    );\n\n    /// Emitted once a stake is scheduled for withdrawal\n    event StakeUnlocked(\n        address indexed account,\n        uint256 withdrawTime\n    );\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit the account's deposit\n     * @param staked true if this account is staked as a paymaster\n     * @param stake actual amount of ether staked for this paymaster.\n     * @param unstakeDelaySec minimum delay to withdraw the stake. must be above the global unstakeDelaySec\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\n     * @dev sizes were chosen so that (deposit,staked) fit into one cell (used during handleOps)\n     *    and the rest fit into a 2nd cell.\n     *    112 bit allows for 10^15 eth\n     *    64 bit for full timestamp\n     *    32 bit allow 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint112 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint64 withdrawTime;\n    }\n\n    //API struct used by getStakeInfo and simulateValidation\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    function getDepositInfo(address account) external view returns (DepositInfo memory info);\n\n    /// return the deposit (for gas payment) of the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * add to the deposit of the given account\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) external payable;\n\n    /**\n     * attempt to unlock the stake.\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * withdraw from the (unlocked) stake.\n     * must first call unlockStake and wait for the unstakeDelay to pass\n     * @param withdrawAddress the address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * withdraw from the deposit.\n     * @param withdrawAddress the address to send withdrawn value.\n     * @param withdrawAmount the amount to withdraw.\n     */\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external;\n}\n"
    },
    "contracts/core/BasePaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IPaymaster.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\n\n/**\n * Helper class for creating a paymaster.\n * provides helper methods for staking.\n * validates that the postOp is called only by the entryPoint\n */\nabstract contract BasePaymaster is IPaymaster, Ownable {\n\n    IEntryPoint public entryPoint;\n\n    constructor(IEntryPoint _entryPoint) {\n        setEntryPoint(_entryPoint);\n    }\n\n    function setEntryPoint(IEntryPoint _entryPoint) public onlyOwner {\n        entryPoint = _entryPoint;\n    }\n\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\n    external virtual override returns (bytes memory context, uint256 sigTimeRange);\n\n    function postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external override {\n        _requireFromEntryPoint();\n        _postOp(mode, context, actualGasCost);\n    }\n\n    /**\n     * post-operation handler.\n     * (verified to be called only through the entryPoint)\n     * @dev if subclass returns a non-empty context from validatePaymasterUserOp, it must also implement this method.\n     * @param mode enum with the following options:\n     *      opSucceeded - user operation succeeded.\n     *      opReverted  - user op reverted. still has to pay for gas.\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\n     * @param context - the context value returned by validatePaymasterUserOp\n     * @param actualGasCost - actual gas used so far (without this postOp call).\n     */\n    function _postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) internal virtual {\n\n        (mode,context,actualGasCost); // unused params\n        // subclass must override this method if validatePaymasterUserOp returns a context\n        revert(\"must override\");\n    }\n\n    /**\n     * add a deposit for this paymaster, used for paying for transaction fees\n     */\n    function deposit() public payable {\n        entryPoint.depositTo{value : msg.value}(address(this));\n    }\n\n    /**\n     * withdraw value from the deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n        entryPoint.withdrawTo(withdrawAddress, amount);\n    }\n    /**\n     * add stake for this paymaster.\n     * This method can also carry eth value to add to the current stake.\n     * @param unstakeDelaySec - the unstake delay for this paymaster. Can only be increased.\n     */\n    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\n        entryPoint.addStake{value : msg.value}(unstakeDelaySec);\n    }\n\n    /**\n     * return current paymaster's deposit on the entryPoint.\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint.balanceOf(address(this));\n    }\n\n    /**\n     * unlock the stake, in order to withdraw it.\n     * The paymaster can't serve requests once unlocked, until it calls addStake again\n     */\n    function unlockStake() external onlyOwner {\n        entryPoint.unlockStake();\n    }\n\n    /**\n     * withdraw the entire paymaster's stake.\n     * stake must be unlocked first (and then wait for the unstakeDelay to be over)\n     * @param withdrawAddress the address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external onlyOwner {\n        entryPoint.withdrawStake(withdrawAddress);\n    }\n\n    /// validate the call is made from a valid entrypoint\n    function _requireFromEntryPoint() internal virtual {\n        require(msg.sender == address(entryPoint));\n    }\n\n    /**\n     * helper to pack the return value for validatePaymasterUserOp\n     * (copy of same method from BaseAccount)\n     * @param sigFailed true if the signature check failed, false, if it succeeded.\n     * @param validUntil last timestamp this UserOperation is valid (or zero for infinite)\n     * @param validAfter first timestamp this UserOperation is valid\n     */\n    function packSigTimeRange(bool sigFailed, uint256 validUntil, uint256 validAfter) internal pure returns (uint256) {\n        return uint256(sigFailed ? 1 : 0) | uint256(validUntil << 8) | uint256(validAfter << (64 + 8));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 9999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}